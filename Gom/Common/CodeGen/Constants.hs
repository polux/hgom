------------------------------------------------------------------
-- |
-- Module      : Gom.Common.CodeGen.Constants
-- Copyright   : (c) Paul Brauner 2009
--               (c) Emilie Balland 2009
--               (c) INRIA 2009
-- Licence     : GPL (see COPYING)
--
-- Maintainer  : paul.brauner@inria.fr
-- Stability   : provisional
-- Portability : non-portable (requires generalized newtype deriving)
--
-- Big 'Doc' constants.
--------------------------------------------------------------------

module Gom.Common.CodeGen.Constants (
  includeSl,
  toStringBody,
  abstractToStringBuilder,
  toHaskellBody,
  abstractToHaskellBuilder,
  abstractSymbolName,
  abstractSharing,
  randomBuiltins,
  abstractSize,
  abstractDepth,
  absParser,
  absLexer,
  hashCodeMethod,
  renderStringMethod,
  renderCharMethod,
) where

import Text.PrettyPrint.Leijen

-- | @include { sl.tom }@ text constant 
includeSl :: Doc
includeSl = text "%include { sl.tom }"

-- | Full text of the toString method of @moduleAbstractType@.
toStringBody :: Doc
toStringBody = vcat $ map text
  ["public String toString() {",
   "  java.lang.StringBuilder buf = new java.lang.StringBuilder();",
   "  toStringBuilder(buf);",
   "  return buf.toString();",
   "}"]

-- | Full prototype of the abstract method of @moduleAbstractType@.
abstractToStringBuilder :: Doc
abstractToStringBuilder = 
  text "public abstract void toStringBuilder(java.lang.StringBuilder buf);"

-- | Full text of the toHaskell method of @moduleAbstractType@.
toHaskellBody :: Doc
toHaskellBody = vcat $ map text
  ["public String toHaskell() {",
  "  java.lang.StringBuilder buf = new java.lang.StringBuilder();",
  "  toHaskellBuilder(buf);",
  "  return buf.toString();",
  "}"]

-- | Full prototype of the abstract method of @moduleAbstractType@.
abstractToHaskellBuilder :: Doc
abstractToHaskellBuilder = 
  text "public abstract void toHaskellBuilder(java.lang.StringBuilder buf);"

-- | Full prototype of the abstract methode of @moduleAbstractType@.
abstractSymbolName :: Doc
abstractSymbolName =
  text "public abstract String symbolName();"

-- | Code of the 
-- @pubic void renderChar(StringBuilder buf, char c)@
-- method
renderCharMethod :: Doc
renderCharMethod = vcat $ map text
  ["public void renderChar(java.lang.StringBuilder buf, char c) {",
   "  buf.append('\\'');",
   "  switch (c) {",
   "    case '\\n':",
   "      buf.append('\\\\');",
   "      buf.append('n');",
   "      break;",
   "    case '\\t':",
   "      buf.append('\\\\');",
   "      buf.append('t');",
   "      break;",
   "    case '\\b':",
   "      buf.append('\\\\');",
   "      buf.append('b');",
   "      break;",
   "    case '\\r':",
   "      buf.append('\\\\');",
   "      buf.append('r');",
   "      break;",
   "    case '\\f':",
   "      buf.append('\\\\');",
   "      buf.append('f');",
   "      break;",
   "    case '\\\\':",
   "      buf.append('\\\\');",
   "      buf.append('\\\\');",
   "      break;",
   "    case '\\'':",
   "      buf.append('\\\\');",
   "      buf.append('\\'');",
   "      break;",
   "      case '\\\"':",
   "        buf.append('\\\\');",
   "      buf.append('\\\"');",
   "      break;",
   "    case '!':",
   "    case '@':",
   "    case '#':",
   "    case '$':",
   "    case '%':",
   "    case '^':",
   "    case '&':",
   "    case '*':",
   "    case '(':",
   "    case ')':",
   "    case '-':",
   "    case '_':",
   "    case '+':",
   "    case '=':",
   "    case '|':",
   "    case '~':",
   "    case '{':",
   "    case '}':",
   "    case '[':",
   "    case ']':",
   "    case ';':",
   "    case ':':",
   "    case '<':",
   "    case '>':",
   "    case ',':",
   "    case '.':",
   "    case '?':",
   "    case ' ':",
   "    case '/':",
   "      buf.append(c);",
   "      break;",
   "",
   "    default:",
   "      if (java.lang.Character.isLetterOrDigit(c)) {",
   "        buf.append(c);",
   "      } else {",
   "        buf.append('\\\\');",
   "        buf.append((char) ('0' + c / 64));",
   "        c = (char) (c % 64);",
   "        buf.append((char) ('0' + c / 8));",
   "        c = (char) (c % 8);",
   "        buf.append((char) ('0' + c));",
   "      }",
   "  }",
   "  buf.append('\\'');",
   "}"]

-- | Code of the 
-- @pubic void renderChar(StringBuilder buf, String s)@
-- method
renderStringMethod :: Doc
renderStringMethod = vcat $ map text
  ["public void renderString(java.lang.StringBuilder buf, String x) {",
   "  buf.append('\"');",
   "  for (int i = 0; i < x.length(); i++) {",
   "    char c = x.charAt(i);",
   "    switch (c) {",
   "      case '\\n':",
   "        buf.append('\\\\');",
   "        buf.append('n');",
   "        break;",
   "      case '\\t':",
   "        buf.append('\\\\');",
   "        buf.append('t');",
   "        break;",
   "      case '\\b':",
   "        buf.append('\\\\');",
   "        buf.append('b');",
   "        break;",
   "      case '\\r':",
   "        buf.append('\\\\');",
   "        buf.append('r');",
   "        break;",
   "      case '\\f':",
   "        buf.append('\\\\');",
   "        buf.append('f');",
   "        break;",
   "      case '\\\\':",
   "        buf.append('\\\\');",
   "        buf.append('\\\\');",
   "        break;",
   "      case '\\'':",
   "        buf.append('\\\\');",
   "        buf.append('\\'');",
   "        break;",
   "      case '\\\"':",
   "        buf.append('\\\\');",
   "        buf.append('\\\"');",
   "        break;",
   "      case '!':",
   "      case '@':",
   "      case '#':",
   "      case '$':",
   "      case '%':",
   "      case '^':",
   "      case '&':",
   "      case '*':",
   "      case '(':",
   "      case ')':",
   "      case '-':",
   "      case '_':",
   "      case '+':",
   "      case '=':",
   "      case '|':",
   "      case '~':",
   "      case '{':",
   "      case '}':",
   "      case '[':",
   "      case ']':",
   "      case ';':",
   "      case ':':",
   "      case '<':",
   "      case '>':",
   "      case ',':",
   "      case '.':",
   "      case '?':",
   "      case ' ':",
   "      case '/':",
   "        buf.append(c);",
   "        break;",
   "  ",
   "      default:",
   "        if (java.lang.Character.isLetterOrDigit(c)) {",
   "          buf.append(c);",
   "        } else {",
   "          buf.append('\\\\');",
   "          buf.append((char) ('0' + c / 64));",
   "          c = (char) (c % 64);",
   "          buf.append((char) ('0' + c / 8));",
   "          c = (char) (c % 8);",
   "          buf.append((char) ('0' + c));",
   "        }",
   "    }",
   "  }",
   "  buf.append('\"');",
   "}"]

-- | declaration of sharing related methods and fields for the
-- modNameAbstractType class
abstractSharing :: Doc
abstractSharing = vcat $ map text
  ["protected static final shared.SharedObjectFactory factory =",
   "   shared.SingletonSharedObjectFactory.getInstance();",
   "private int uniqueID;",
   "public int getUniqueIdentifier() {",
   "  return uniqueID;",
   "}",
   "public void setUniqueIdentifier(int uniqueID) {",
   "  this.uniqueID = uniqueID;",
   "}"]

-- | declaration of random related methods for the
-- modNameAbstractType class
randomBuiltins :: Doc
randomBuiltins = vcat $ map text
  ["public final static long randomlong(java.util.Random rand) {",
   "  return rand.nextLong();",
   "}",
   "public final static boolean randomboolean(java.util.Random rand) {",
   "  return rand.nextBoolean();",
   "}",
   "public final static int randomint(java.util.Random rand) {",
   "  return rand.nextInt();",
   "}",
   "public final static double randomdouble(java.util.Random rand) {",
   "  return rand.nextDouble();",
   "}",
   "public final static float randomfloat(java.util.Random rand) {",
   "  return rand.nextFloat();",
   "}",
   "public static char randomchar(java.util.Random rand) {",
   "  return (char) rand.nextInt(256);",
   "}",
   "public static String randomString(java.util.Random rand) {",
   "  int n = rand.nextInt(10);",
   "  char buf[] = new char[n];",
   "  for (int i=0; i<n; i++) {",
   "    buf[i] = (char) rand.nextInt(256);",
   "  }",
   "  return new String(buf);",
   "}"]

-- | declaration of the @hashCode@ method which returns the private 
-- @hashCode@ member of a constructor
hashCodeMethod :: Doc
hashCodeMethod = vcat $ map text 
  ["public final int hashCode() {",
   "  return hashCode;",
   "}"]

-- | declaration of the @depth@ abstract method
abstractDepth :: Doc
abstractDepth = text "public abstract int depth();"

-- | declaration of the @size@ abstract method
abstractSize :: Doc
abstractSize = text "public abstract int size();"

-- | The parser class generated in package @mod@.
absParser :: Doc
absParser = vcat $ map text 
  ["public class Parser {",
   "  private Lexer lex;",
   "  private Lexer.Token cur;",
   "  public Parser(String _s) {",
   "    this.lex = new Lexer(new java.io.StringReader(_s));",
   "    next();",
   "  }",
   "  public final boolean isRpar() {",
   "    return cur.type == Lexer.TokenType.RPAR;",
   "  }",
   "  public final boolean isComma() {",
   "    return cur.type == Lexer.TokenType.COMMA;",
   "  }",
   "  final void next() {",
   "    try { cur = lex.yylex(); }",
   "    catch (java.io.IOException e) {",
   "     throw new RuntimeException();",
   "    }",
   "  }",
   "  public final boolean parseboolean() {",
   "    switch (cur.type) {",
   "      case TRUE:",
   "        next();",
   "        return true;",
   "      case FALSE:",
   "        next();",
   "        return false;",
   "      default:",
   "       throw new RuntimeException();",
   "    }",
   "  }",
   "  public final String parseString() {",
   "    if (cur.type == Lexer.TokenType.STRING) {",
   "      String res = cur.string;",
   "      next();",
   "      return res;",
   "    }",
   "    else throw new RuntimeException();",
   "  }",
   "  public final int parseint() {",
   "    if (cur.type == Lexer.TokenType.INTEGRAL) {",
   "      int res = Integer.valueOf(cur.string);",
   "      next();",
   "      return res;",
   "    }",
   "    else throw new RuntimeException();",
   "  }",
   "  public final long parselong() {",
   "    if (cur.type == Lexer.TokenType.INTEGRAL) {",
   "      long res = Long.valueOf(cur.string);",
   "      next();",
   "      return res;",
   "    }",
   "    else throw new RuntimeException();",
   "  }",
   "  public final float parsefloat() {",
   "    if (cur.type == Lexer.TokenType.DECIMAL) {",
   "      float res = Float.valueOf(cur.string);",
   "      next();",
   "      return res;",
   "    }",
   "    else throw new RuntimeException();",
   "  }",
   "  public final double parsedouble() {",
   "    if (cur.type == Lexer.TokenType.DECIMAL) {",
   "      double res = Double.valueOf(cur.string);",
   "      next();",
   "      return res;",
   "    }",
   "    else throw new RuntimeException();",
   "  }",
   "  public final char parsechar() {",
   "    if (cur.type == Lexer.TokenType.CHAR) {",
   "      char res = cur.string.charAt(1);",
   "      next();",
   "      return res;",
   "    }",
   "    else throw new RuntimeException();",
   "  }",
   "  public final String parseId() {",
   "    if (cur.type == Lexer.TokenType.IDENTIFIER) {",
   "      String res = cur.string;",
   "      next();",
   "      return res;",
   "    }",
   "    else throw new RuntimeException();",
   "  }",
   "  public final void parseLpar() { ",
   "    if (cur.type == Lexer.TokenType.LPAR) {",
   "      next();",
   "      return;",
   "    }",
   "    else throw new RuntimeException();",
   "  }",
   "  public final void parseRpar() {",
   "    if (cur.type == Lexer.TokenType.RPAR) {",
   "      next();",
   "      return;",
   "    }",
   "    else throw new RuntimeException();",
   "  }",
   "  public final void parseComma() {",
   "    if (cur.type == Lexer.TokenType.COMMA) {",
   "      next();",
   "      return;",
   "    }",
   "    else throw new RuntimeException();",
   "  }",
   "}"]

-- | The lexer class generated in package @mod@.
absLexer :: Doc
absLexer = vcat $ map text 
  ["/* generated by JFlex */",
   "class Lexer {",
   "  public static final int YYEOF = -1;",
   "  private static final int ZZ_BUFFERSIZE = 16384;",
   "  public static final int STRING = 2;",
   "  public static final int YYINITIAL = 0;",
   "  private static final int ZZ_LEXSTATE[] = { ",
   "     0,  0,  1, 1",
   "  };",
   "  private static final String ZZ_CMAP_PACKED = ",
   "    \"\\11\\15\\1\\3\\1\\2\\1\\0\\1\\3\\1\\1\\16\\15\\4\\0\\1\\3\\1\\0\"+",
   "    \"\\1\\26\\1\\0\\1\\14\\2\\0\\1\\25\\1\\22\\1\\23\\2\\0\\1\\24\\1\\16\"+",
   "    \"\\1\\20\\1\\0\\4\\30\\4\\31\\2\\17\\7\\0\\4\\14\\1\\21\\25\\14\\1\\0\"+",
   "    \"\\1\\27\\2\\0\\1\\14\\1\\0\\1\\11\\1\\33\\2\\14\\1\\7\\1\\10\\5\\14\"+",
   "    \"\\1\\12\\1\\14\\1\\32\\3\\14\\1\\5\\1\\13\\1\\4\\1\\6\\5\\14\\4\\0\"+",
   "    \"\\41\\15\\2\\0\\4\\14\\4\\0\\1\\14\\2\\0\\1\\15\\7\\0\\1\\14\\4\\0\"+",
   "    \"\\1\\14\\5\\0\\27\\14\\1\\0\\37\\14\\1\\0\\u013f\\14\\31\\0\\162\\14\\4\\0\"+",
   "    \"\\14\\14\\16\\0\\5\\14\\11\\0\\1\\14\\21\\0\\130\\15\\5\\0\\23\\15\\12\\0\"+",
   "    \"\\1\\14\\13\\0\\1\\14\\1\\0\\3\\14\\1\\0\\1\\14\\1\\0\\24\\14\\1\\0\"+",
   "    \"\\54\\14\\1\\0\\46\\14\\1\\0\\5\\14\\4\\0\\202\\14\\1\\0\\4\\15\\3\\0\"+",
   "    \"\\105\\14\\1\\0\\46\\14\\2\\0\\2\\14\\6\\0\\20\\14\\41\\0\\46\\14\\2\\0\"+",
   "    \"\\1\\14\\7\\0\\47\\14\\11\\0\\21\\15\\1\\0\\27\\15\\1\\0\\3\\15\\1\\0\"+",
   "    \"\\1\\15\\1\\0\\2\\15\\1\\0\\1\\15\\13\\0\\33\\14\\5\\0\\3\\14\\15\\0\"+",
   "    \"\\4\\15\\14\\0\\6\\15\\13\\0\\32\\14\\5\\0\\13\\14\\16\\15\\7\\0\\12\\15\"+",
   "    \"\\4\\0\\2\\14\\1\\15\\143\\14\\1\\0\\1\\14\\10\\15\\1\\0\\6\\15\\2\\14\"+",
   "    \"\\2\\15\\1\\0\\4\\15\\2\\14\\12\\15\\3\\14\\2\\0\\1\\14\\17\\0\\1\\15\"+",
   "    \"\\1\\14\\1\\15\\36\\14\\33\\15\\2\\0\\3\\14\\60\\0\\46\\14\\13\\15\\1\\14\"+",
   "    \"\\u014f\\0\\3\\15\\66\\14\\2\\0\\1\\15\\1\\14\\20\\15\\2\\0\\1\\14\\4\\15\"+",
   "    \"\\3\\0\\12\\14\\2\\15\\2\\0\\12\\15\\21\\0\\3\\15\\1\\0\\10\\14\\2\\0\"+",
   "    \"\\2\\14\\2\\0\\26\\14\\1\\0\\7\\14\\1\\0\\1\\14\\3\\0\\4\\14\\2\\0\"+",
   "    \"\\1\\15\\1\\14\\7\\15\\2\\0\\2\\15\\2\\0\\3\\15\\11\\0\\1\\15\\4\\0\"+",
   "    \"\\2\\14\\1\\0\\3\\14\\2\\15\\2\\0\\12\\15\\4\\14\\15\\0\\3\\15\\1\\0\"+",
   "    \"\\6\\14\\4\\0\\2\\14\\2\\0\\26\\14\\1\\0\\7\\14\\1\\0\\2\\14\\1\\0\"+",
   "    \"\\2\\14\\1\\0\\2\\14\\2\\0\\1\\15\\1\\0\\5\\15\\4\\0\\2\\15\\2\\0\"+",
   "    \"\\3\\15\\13\\0\\4\\14\\1\\0\\1\\14\\7\\0\\14\\15\\3\\14\\14\\0\\3\\15\"+",
   "    \"\\1\\0\\11\\14\\1\\0\\3\\14\\1\\0\\26\\14\\1\\0\\7\\14\\1\\0\\2\\14\"+",
   "    \"\\1\\0\\5\\14\\2\\0\\1\\15\\1\\14\\10\\15\\1\\0\\3\\15\\1\\0\\3\\15\"+",
   "    \"\\2\\0\\1\\14\\17\\0\\2\\14\\2\\15\\2\\0\\12\\15\\1\\0\\1\\14\\17\\0\"+",
   "    \"\\3\\15\\1\\0\\10\\14\\2\\0\\2\\14\\2\\0\\26\\14\\1\\0\\7\\14\\1\\0\"+",
   "    \"\\2\\14\\1\\0\\5\\14\\2\\0\\1\\15\\1\\14\\6\\15\\3\\0\\2\\15\\2\\0\"+",
   "    \"\\3\\15\\10\\0\\2\\15\\4\\0\\2\\14\\1\\0\\3\\14\\4\\0\\12\\15\\1\\0\"+",
   "    \"\\1\\14\\20\\0\\1\\15\\1\\14\\1\\0\\6\\14\\3\\0\\3\\14\\1\\0\\4\\14\"+",
   "    \"\\3\\0\\2\\14\\1\\0\\1\\14\\1\\0\\2\\14\\3\\0\\2\\14\\3\\0\\3\\14\"+",
   "    \"\\3\\0\\10\\14\\1\\0\\3\\14\\4\\0\\5\\15\\3\\0\\3\\15\\1\\0\\4\\15\"+",
   "    \"\\11\\0\\1\\15\\17\\0\\11\\15\\11\\0\\1\\14\\7\\0\\3\\15\\1\\0\\10\\14\"+",
   "    \"\\1\\0\\3\\14\\1\\0\\27\\14\\1\\0\\12\\14\\1\\0\\5\\14\\4\\0\\7\\15\"+",
   "    \"\\1\\0\\3\\15\\1\\0\\4\\15\\7\\0\\2\\15\\11\\0\\2\\14\\4\\0\\12\\15\"+",
   "    \"\\22\\0\\2\\15\\1\\0\\10\\14\\1\\0\\3\\14\\1\\0\\27\\14\\1\\0\\12\\14\"+",
   "    \"\\1\\0\\5\\14\\2\\0\\1\\15\\1\\14\\7\\15\\1\\0\\3\\15\\1\\0\\4\\15\"+",
   "    \"\\7\\0\\2\\15\\7\\0\\1\\14\\1\\0\\2\\14\\4\\0\\12\\15\\22\\0\\2\\15\"+",
   "    \"\\1\\0\\10\\14\\1\\0\\3\\14\\1\\0\\27\\14\\1\\0\\20\\14\\4\\0\\6\\15\"+",
   "    \"\\2\\0\\3\\15\\1\\0\\4\\15\\11\\0\\1\\15\\10\\0\\2\\14\\4\\0\\12\\15\"+",
   "    \"\\22\\0\\2\\15\\1\\0\\22\\14\\3\\0\\30\\14\\1\\0\\11\\14\\1\\0\\1\\14\"+",
   "    \"\\2\\0\\7\\14\\3\\0\\1\\15\\4\\0\\6\\15\\1\\0\\1\\15\\1\\0\\10\\15\"+",
   "    \"\\22\\0\\2\\15\\15\\0\\60\\14\\1\\15\\2\\14\\7\\15\\4\\0\\10\\14\\10\\15\"+",
   "    \"\\1\\0\\12\\15\\47\\0\\2\\14\\1\\0\\1\\14\\2\\0\\2\\14\\1\\0\\1\\14\"+",
   "    \"\\2\\0\\1\\14\\6\\0\\4\\14\\1\\0\\7\\14\\1\\0\\3\\14\\1\\0\\1\\14\"+",
   "    \"\\1\\0\\1\\14\\2\\0\\2\\14\\1\\0\\4\\14\\1\\15\\2\\14\\6\\15\\1\\0\"+",
   "    \"\\2\\15\\1\\14\\2\\0\\5\\14\\1\\0\\1\\14\\1\\0\\6\\15\\2\\0\\12\\15\"+",
   "    \"\\2\\0\\2\\14\\42\\0\\1\\14\\27\\0\\2\\15\\6\\0\\12\\15\\13\\0\\1\\15\"+",
   "    \"\\1\\0\\1\\15\\1\\0\\1\\15\\4\\0\\2\\15\\10\\14\\1\\0\\42\\14\\6\\0\"+",
   "    \"\\24\\15\\1\\0\\2\\15\\4\\14\\4\\0\\10\\15\\1\\0\\44\\15\\11\\0\\1\\15\"+",
   "    \"\\71\\0\\42\\14\\1\\0\\5\\14\\1\\0\\2\\14\\1\\0\\7\\15\\3\\0\\4\\15\"+",
   "    \"\\6\\0\\12\\15\\6\\0\\6\\14\\4\\15\\106\\0\\46\\14\\12\\0\\51\\14\\7\\0\"+",
   "    \"\\132\\14\\5\\0\\104\\14\\5\\0\\122\\14\\6\\0\\7\\14\\1\\0\\77\\14\\1\\0\"+",
   "    \"\\1\\14\\1\\0\\4\\14\\2\\0\\7\\14\\1\\0\\1\\14\\1\\0\\4\\14\\2\\0\"+",
   "    \"\\47\\14\\1\\0\\1\\14\\1\\0\\4\\14\\2\\0\\37\\14\\1\\0\\1\\14\\1\\0\"+",
   "    \"\\4\\14\\2\\0\\7\\14\\1\\0\\1\\14\\1\\0\\4\\14\\2\\0\\7\\14\\1\\0\"+",
   "    \"\\7\\14\\1\\0\\27\\14\\1\\0\\37\\14\\1\\0\\1\\14\\1\\0\\4\\14\\2\\0\"+",
   "    \"\\7\\14\\1\\0\\47\\14\\1\\0\\23\\14\\16\\0\\11\\15\\56\\0\\125\\14\\14\\0\"+",
   "    \"\\u026c\\14\\2\\0\\10\\14\\12\\0\\32\\14\\5\\0\\113\\14\\3\\0\\3\\14\\17\\0\"+",
   "    \"\\15\\14\\1\\0\\4\\14\\3\\15\\13\\0\\22\\14\\3\\15\\13\\0\\22\\14\\2\\15\"+",
   "    \"\\14\\0\\15\\14\\1\\0\\3\\14\\1\\0\\2\\15\\14\\0\\64\\14\\40\\15\\3\\0\"+",
   "    \"\\1\\14\\3\\0\\2\\14\\1\\15\\2\\0\\12\\15\\41\\0\\3\\15\\2\\0\\12\\15\"+",
   "    \"\\6\\0\\130\\14\\10\\0\\51\\14\\1\\15\\126\\0\\35\\14\\3\\0\\14\\15\\4\\0\"+",
   "    \"\\14\\15\\12\\0\\12\\15\\36\\14\\2\\0\\5\\14\\u038b\\0\\154\\14\\224\\0\\234\\14\"+",
   "    \"\\4\\0\\132\\14\\6\\0\\26\\14\\2\\0\\6\\14\\2\\0\\46\\14\\2\\0\\6\\14\"+",
   "    \"\\2\\0\\10\\14\\1\\0\\1\\14\\1\\0\\1\\14\\1\\0\\1\\14\\1\\0\\37\\14\"+",
   "    \"\\2\\0\\65\\14\\1\\0\\7\\14\\1\\0\\1\\14\\3\\0\\3\\14\\1\\0\\7\\14\"+",
   "    \"\\3\\0\\4\\14\\2\\0\\6\\14\\4\\0\\15\\14\\5\\0\\3\\14\\1\\0\\7\\14\"+",
   "    \"\\17\\0\\4\\15\\32\\0\\5\\15\\20\\0\\2\\14\\23\\0\\1\\14\\13\\0\\4\\15\"+",
   "    \"\\6\\0\\6\\15\\1\\0\\1\\14\\15\\0\\1\\14\\40\\0\\22\\14\\36\\0\\15\\15\"+",
   "    \"\\4\\0\\1\\15\\3\\0\\6\\15\\27\\0\\1\\14\\4\\0\\1\\14\\2\\0\\12\\14\"+",
   "    \"\\1\\0\\1\\14\\3\\0\\5\\14\\6\\0\\1\\14\\1\\0\\1\\14\\1\\0\\1\\14\"+",
   "    \"\\1\\0\\4\\14\\1\\0\\3\\14\\1\\0\\7\\14\\3\\0\\3\\14\\5\\0\\5\\14\"+",
   "    \"\\26\\0\\44\\14\\u0e81\\0\\3\\14\\31\\0\\11\\14\\6\\15\\1\\0\\5\\14\\2\\0\"+",
   "    \"\\5\\14\\4\\0\\126\\14\\2\\0\\2\\15\\2\\0\\3\\14\\1\\0\\137\\14\\5\\0\"+",
   "    \"\\50\\14\\4\\0\\136\\14\\21\\0\\30\\14\\70\\0\\20\\14\\u0200\\0\\u19b6\\14\\112\\0\"+",
   "    \"\\u51a6\\14\\132\\0\\u048d\\14\\u0773\\0\\u2ba4\\14\\u215c\\0\\u012e\\14\\2\\0\\73\\14\\225\\0\"+",
   "    \"\\7\\14\\14\\0\\5\\14\\5\\0\\1\\14\\1\\15\\12\\14\\1\\0\\15\\14\\1\\0\"+",
   "    \"\\5\\14\\1\\0\\1\\14\\1\\0\\2\\14\\1\\0\\2\\14\\1\\0\\154\\14\\41\\0\"+",
   "    \"\\u016b\\14\\22\\0\\100\\14\\2\\0\\66\\14\\50\\0\\15\\14\\3\\0\\20\\15\\20\\0\"+",
   "    \"\\4\\15\\17\\0\\2\\14\\30\\0\\3\\14\\31\\0\\1\\14\\6\\0\\5\\14\\1\\0\"+",
   "    \"\\207\\14\\2\\0\\1\\15\\4\\0\\1\\14\\13\\0\\12\\15\\7\\0\\32\\14\\4\\0\"+",
   "    \"\\1\\14\\1\\0\\32\\14\\12\\0\\132\\14\\3\\0\\6\\14\\2\\0\\6\\14\\2\\0\"+",
   "    \"\\6\\14\\2\\0\\3\\14\\3\\0\\2\\14\\3\\0\\2\\14\\22\\0\\3\\15\\4\\0\";",
   "  private static final char [] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);",
   "  private static final int [] ZZ_ACTION = zzUnpackAction();",
   "  private static final String ZZ_ACTION_PACKED_0 =",
   "    \"\\2\\0\\1\\1\\2\\2\\3\\3\\1\\1\\1\\4\\1\\5\\1\\6\"+",
   "    \"\\1\\7\\1\\1\\1\\10\\1\\11\\1\\12\\1\\1\\2\\3\\2\\0\"+",
   "    \"\\1\\13\\1\\14\\1\\15\\1\\16\\1\\17\\1\\20\\2\\21\\1\\22\"+",
   "    \"\\1\\23\\2\\3\\1\\24\\1\\25\\1\\26\\1\\27\\1\\3\\1\\0\"+",
   "    \"\\1\\30\\1\\31\\1\\0\\1\\24\";",
   "  private static int [] zzUnpackAction() {",
   "    int [] result = new int[44];",
   "    int offset = 0;",
   "    offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);",
   "    return result;",
   "  }",
   "  private static int zzUnpackAction(String packed, int offset, int [] result) {",
   "    int i = 0;       ",
   "    int j = offset;  ",
   "    int l = packed.length();",
   "    while (i < l) {",
   "      int count = packed.charAt(i++);",
   "      int value = packed.charAt(i++);",
   "      do result[j++] = value; while (--count > 0);",
   "    }",
   "    return j;",
   "  }",
   "  private static final int [] ZZ_ROWMAP = zzUnpackRowMap();",
   "  private static final String ZZ_ROWMAP_PACKED_0 =",
   "    \"\\0\\0\\0\\34\\0\\70\\0\\124\\0\\70\\0\\160\\0\\214\\0\\250\"+",
   "    \"\\0\\304\\0\\340\\0\\70\\0\\70\\0\\70\\0\\374\\0\\70\\0\\u0118\"+",
   "    \"\\0\\70\\0\\u0134\\0\\u0150\\0\\u016c\\0\\u0188\\0\\u01a4\\0\\70\\0\\70\"+",
   "    \"\\0\\70\\0\\70\\0\\70\\0\\70\\0\\u01c0\\0\\70\\0\\70\\0\\70\"+",
   "    \"\\0\\u01dc\\0\\u01f8\\0\\u0214\\0\\70\\0\\u0230\\0\\214\\0\\u024c\\0\\u0268\"+",
   "    \"\\0\\70\\0\\214\\0\\u0284\\0\\u0284\";",
   "  private static int [] zzUnpackRowMap() {",
   "    int [] result = new int[44];",
   "    int offset = 0;",
   "    offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);",
   "    return result;",
   "  }",
   "  private static int zzUnpackRowMap(String packed, int offset, int [] result) {",
   "    int i = 0;  ",
   "    int j = offset;  ",
   "    int l = packed.length();",
   "    while (i < l) {",
   "      int high = packed.charAt(i++) << 16;",
   "      result[j++] = high | packed.charAt(i++);",
   "    }",
   "    return j;",
   "  }",
   "  private static final int [] ZZ_TRANS = zzUnpackTrans();",
   "  private static final String ZZ_TRANS_PACKED_0 =",
   "    \"\\1\\3\\1\\4\\2\\5\\1\\6\\3\\7\\1\\10\\4\\7\\1\\3\"+",
   "    \"\\1\\11\\1\\12\\1\\3\\1\\7\\1\\13\\1\\14\\1\\15\\1\\16\"+",
   "    \"\\1\\17\\1\\3\\2\\12\\2\\7\\1\\20\\1\\3\\1\\0\\23\\20\"+",
   "    \"\\1\\21\\1\\22\\4\\20\\36\\0\\1\\5\\35\\0\\1\\7\\1\\23\"+",
   "    \"\\10\\7\\1\\0\\1\\7\\1\\0\\1\\7\\6\\0\\4\\7\\4\\0\"+",
   "    \"\\12\\7\\1\\0\\1\\7\\1\\0\\1\\7\\6\\0\\4\\7\\4\\0\"+",
   "    \"\\5\\7\\1\\24\\4\\7\\1\\0\\1\\7\\1\\0\\1\\7\\6\\0\"+",
   "    \"\\4\\7\\17\\0\\1\\12\\10\\0\\2\\12\\21\\0\\1\\12\\1\\25\"+",
   "    \"\\7\\0\\2\\12\\6\\0\\12\\26\\1\\0\\1\\26\\1\\0\\1\\26\"+",
   "    \"\\6\\0\\4\\26\\1\\20\\2\\0\\23\\20\\2\\0\\4\\20\\4\\0\"+",
   "    \"\\1\\27\\1\\30\\2\\0\\1\\31\\14\\0\\1\\32\\1\\33\\1\\34\"+",
   "    \"\\1\\35\\1\\36\\1\\37\\1\\40\\4\\0\\2\\7\\1\\41\\7\\7\"+",
   "    \"\\1\\0\\1\\7\\1\\0\\1\\7\\6\\0\\4\\7\\4\\0\\6\\7\"+",
   "    \"\\1\\42\\3\\7\\1\\0\\1\\7\\1\\0\\1\\7\\6\\0\\4\\7\"+",
   "    \"\\17\\0\\1\\43\\10\\0\\2\\43\\27\\0\\1\\44\\36\\0\\2\\45\"+",
   "    \"\\6\\0\\3\\7\\1\\46\\6\\7\\1\\0\\1\\7\\1\\0\\1\\7\"+",
   "    \"\\6\\0\\4\\7\\4\\0\\7\\7\\1\\47\\2\\7\\1\\0\\1\\7\"+",
   "    \"\\1\\0\\1\\7\\6\\0\\4\\7\\17\\0\\1\\43\\1\\0\\1\\50\"+",
   "    \"\\6\\0\\2\\43\\32\\0\\2\\51\\6\\0\\3\\7\\1\\52\\6\\7\"+",
   "    \"\\1\\0\\1\\7\\1\\0\\1\\7\\6\\0\\4\\7\\16\\0\\1\\53\"+",
   "    \"\\1\\54\\10\\0\\2\\54\\21\\0\\1\\54\\10\\0\\2\\54\\2\\0\";",
   "  private static int [] zzUnpackTrans() {",
   "    int [] result = new int[672];",
   "    int offset = 0;",
   "    offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);",
   "    return result;",
   "  }",
   "  private static int zzUnpackTrans(String packed, int offset, int [] result) {",
   "    int i = 0;       ",
   "    int j = offset;  ",
   "    int l = packed.length();",
   "    while (i < l) {",
   "      int count = packed.charAt(i++);",
   "      int value = packed.charAt(i++);",
   "      value--;",
   "      do result[j++] = value; while (--count > 0);",
   "    }",
   "    return j;",
   "  }",
   "  private static final int ZZ_UNKNOWN_ERROR = 0;",
   "  private static final int ZZ_NO_MATCH = 1;",
   "  private static final int ZZ_PUSHBACK_2BIG = 2;",
   "  private static final String ZZ_ERROR_MSG[] = {",
   "    \"Unkown internal scanner error\",",
   "    \"Error: could not match input\",",
   "    \"Error: pushback value was too large\"",
   "  };",
   "  private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();",
   "  private static final String ZZ_ATTRIBUTE_PACKED_0 =",
   "    \"\\2\\0\\1\\11\\1\\1\\1\\11\\5\\1\\3\\11\\1\\1\\1\\11\"+",
   "    \"\\1\\1\\1\\11\\3\\1\\2\\0\\6\\11\\1\\1\\3\\11\\3\\1\"+",
   "    \"\\1\\11\\3\\1\\1\\0\\1\\11\\1\\1\\1\\0\\1\\1\";",
   "  private static int [] zzUnpackAttribute() {",
   "    int [] result = new int[44];",
   "    int offset = 0;",
   "    offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);",
   "    return result;",
   "  }",
   "  private static int zzUnpackAttribute(String packed, int offset, int [] result) {",
   "    int i = 0;       ",
   "    int j = offset;  ",
   "    int l = packed.length();",
   "    while (i < l) {",
   "      int count = packed.charAt(i++);",
   "      int value = packed.charAt(i++);",
   "      do result[j++] = value; while (--count > 0);",
   "    }",
   "    return j;",
   "  }",
   "  private java.io.Reader zzReader;",
   "  private int zzState;",
   "  private int zzLexicalState = YYINITIAL;",
   "  private char zzBuffer[] = new char[ZZ_BUFFERSIZE];",
   "  private int zzMarkedPos;",
   "  private int zzCurrentPos;",
   "  private int zzStartRead;",
   "  private int zzEndRead;",
   "  private int yyline;",
   "  private int yychar;",
   "  private int yycolumn;",
   "  private boolean zzAtBOL = true;",
   "  private boolean zzAtEOF;",
   "  StringBuffer string = new StringBuffer();",
   "  enum TokenType { IDENTIFIER, INTEGRAL, STRING, LPAR, RPAR, COMMA, CHAR, DECIMAL, TRUE, FALSE } ;",
   "  public class Token { ",
   "    public Token(TokenType t, String s) { type = t; string = s; }",
   "    TokenType type; ",
   "    String string; ",
   "  } ",
   "  Lexer(java.io.Reader in) {",
   "    this.zzReader = in;",
   "  }",
   "  Lexer(java.io.InputStream in) {",
   "    this(new java.io.InputStreamReader(in));",
   "  }",
   "  private static char [] zzUnpackCMap(String packed) {",
   "    char [] map = new char[0x10000];",
   "    int i = 0;  ",
   "    int j = 0;  ",
   "    while (i < 1720) {",
   "      int  count = packed.charAt(i++);",
   "      char value = packed.charAt(i++);",
   "      do map[j++] = value; while (--count > 0);",
   "    }",
   "    return map;",
   "  }",
   "  private boolean zzRefill() throws java.io.IOException {",
   "    if (zzStartRead > 0) {",
   "      System.arraycopy(zzBuffer, zzStartRead,",
   "                       zzBuffer, 0,",
   "                       zzEndRead-zzStartRead);",
   "      zzEndRead-= zzStartRead;",
   "      zzCurrentPos-= zzStartRead;",
   "      zzMarkedPos-= zzStartRead;",
   "      zzStartRead = 0;",
   "    }",
   "    if (zzCurrentPos >= zzBuffer.length) {",
   "      char newBuffer[] = new char[zzCurrentPos*2];",
   "      System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);",
   "      zzBuffer = newBuffer;",
   "    }",
   "    int numRead = zzReader.read(zzBuffer, zzEndRead,",
   "                                            zzBuffer.length-zzEndRead);",
   "    if (numRead > 0) {",
   "      zzEndRead+= numRead;",
   "      return false;",
   "    }",
   "    // unlikely but not impossible: read 0 characters, but not at end of stream    ",
   "    if (numRead == 0) {",
   "      int c = zzReader.read();",
   "      if (c == -1) {",
   "        return true;",
   "      } else {",
   "        zzBuffer[zzEndRead++] = (char) c;",
   "        return false;",
   "      }     ",
   "    }",
   "\t// numRead < 0",
   "    return true;",
   "  }",
   "  public final void yyclose() throws java.io.IOException {",
   "    zzAtEOF = true;            ",
   "    zzEndRead = zzStartRead;  ",
   "    if (zzReader != null)",
   "      zzReader.close();",
   "  }",
   "  public final void yyreset(java.io.Reader reader) {",
   "    zzReader = reader;",
   "    zzAtBOL  = true;",
   "    zzAtEOF  = false;",
   "    zzEndRead = zzStartRead = 0;",
   "    zzCurrentPos = zzMarkedPos = 0;",
   "    yyline = yychar = yycolumn = 0;",
   "    zzLexicalState = YYINITIAL;",
   "  }",
   "  public final int yystate() {",
   "    return zzLexicalState;",
   "  }",
   "  public final void yybegin(int newState) {",
   "    zzLexicalState = newState;",
   "  }",
   "  public final String yytext() {",
   "    return new String( zzBuffer, zzStartRead, zzMarkedPos-zzStartRead );",
   "  }",
   "  public final char yycharat(int pos) {",
   "    return zzBuffer[zzStartRead+pos];",
   "  }",
   "  public final int yylength() {",
   "    return zzMarkedPos-zzStartRead;",
   "  }",
   "  private void zzScanError(int errorCode) {",
   "    String message;",
   "    try {",
   "      message = ZZ_ERROR_MSG[errorCode];",
   "    }",
   "    catch (ArrayIndexOutOfBoundsException e) {",
   "      message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];",
   "    }",
   "    throw new Error(message);",
   "  } ",
   "  public void yypushback(int number)  {",
   "    if ( number > yylength() )",
   "      zzScanError(ZZ_PUSHBACK_2BIG);",
   "    zzMarkedPos -= number;",
   "  }",
   "  public Token yylex() throws java.io.IOException {",
   "    int zzInput;",
   "    int zzAction;",
   "    // cached fields:",
   "    int zzCurrentPosL;",
   "    int zzMarkedPosL;",
   "    int zzEndReadL = zzEndRead;",
   "    char [] zzBufferL = zzBuffer;",
   "    char [] zzCMapL = ZZ_CMAP;",
   "    int [] zzTransL = ZZ_TRANS;",
   "    int [] zzRowMapL = ZZ_ROWMAP;",
   "    int [] zzAttrL = ZZ_ATTRIBUTE;",
   "    while (true) {",
   "      zzMarkedPosL = zzMarkedPos;",
   "      zzAction = -1;",
   "      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;",
   "      zzState = ZZ_LEXSTATE[zzLexicalState];",
   "      zzForAction: {",
   "        while (true) {",
   "          if (zzCurrentPosL < zzEndReadL)",
   "            zzInput = zzBufferL[zzCurrentPosL++];",
   "          else if (zzAtEOF) {",
   "            zzInput = YYEOF;",
   "            break zzForAction;",
   "          }",
   "          else {",
   "            // store back cached positions",
   "            zzCurrentPos  = zzCurrentPosL;",
   "            zzMarkedPos   = zzMarkedPosL;",
   "            boolean eof = zzRefill();",
   "            // get translated positions and possibly new buffer",
   "            zzCurrentPosL  = zzCurrentPos;",
   "            zzMarkedPosL   = zzMarkedPos;",
   "            zzBufferL      = zzBuffer;",
   "            zzEndReadL     = zzEndRead;",
   "            if (eof) {",
   "              zzInput = YYEOF;",
   "              break zzForAction;",
   "            }",
   "            else {",
   "              zzInput = zzBufferL[zzCurrentPosL++];",
   "            }",
   "          }",
   "          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];",
   "          if (zzNext == -1) break zzForAction;",
   "          zzState = zzNext;",
   "          int zzAttributes = zzAttrL[zzState];",
   "          if ( (zzAttributes & 1) == 1 ) {",
   "            zzAction = zzState;",
   "            zzMarkedPosL = zzCurrentPosL;",
   "            if ( (zzAttributes & 8) == 8 ) break zzForAction;",
   "          }",
   "        }",
   "      }",
   "      // store back cached position",
   "      zzMarkedPos = zzMarkedPosL;",
   "      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {",
   "        case 18: ",
   "          { string.append('\\n');",
   "          }",
   "        case 26: break;",
   "        case 5: ",
   "          { return new Token(TokenType.LPAR,\"(\");",
   "          }",
   "        case 27: break;",
   "        case 9: ",
   "          { string.append( yytext() );",
   "          }",
   "        case 28: break;",
   "        case 6: ",
   "          { return new Token(TokenType.RPAR,\")\");",
   "          }",
   "        case 29: break;",
   "        case 24: ",
   "          { String text = yytext();",
   "                                   int x2 = Character.digit(text.charAt(1),4);",
   "                                   int x1 = Character.digit(text.charAt(2),8);",
   "                                   int x0 = Character.digit(text.charAt(3),8);",
   "                                   string.append( (char) (x0 + 8 * x1 + 64 * x2) );",
   "          }",
   "        case 30: break;",
   "        case 17: ",
   "          { String text = yytext();",
   "                                   int x0 = Character.digit(text.charAt(3),8);",
   "                                   string.append( (char) x0 );",
   "          }",
   "        case 31: break;",
   "        case 19: ",
   "          { string.append('\\b');",
   "          }",
   "        case 32: break;",
   "        case 21: ",
   "          { return new Token(TokenType.CHAR,yytext());",
   "          }",
   "        case 33: break;",
   "        case 16: ",
   "          { string.append('\\\\');",
   "          }",
   "        case 34: break;",
   "        case 22: ",
   "          { String text = yytext();",
   "                                   int x1 = Character.digit(text.charAt(2),4);",
   "                                   int x0 = Character.digit(text.charAt(3),8);",
   "                                   string.append( (char) (x0 + 8 * x1) );",
   "          }",
   "        case 35: break;",
   "        case 3: ",
   "          { return new Token(TokenType.IDENTIFIER,yytext());",
   "          }",
   "        case 36: break;",
   "        case 7: ",
   "          { return new Token(TokenType.COMMA,\",\");",
   "          }",
   "        case 37: break;",
   "        case 8: ",
   "          { string.setLength(0); yybegin(STRING);",
   "          }",
   "        case 38: break;",
   "        case 14: ",
   "          { string.append('\\'');",
   "          }",
   "        case 39: break;",
   "        case 25: ",
   "          { return new Token(TokenType.FALSE,\"false\");",
   "          }",
   "        case 40: break;",
   "        case 23: ",
   "          { return new Token(TokenType.TRUE,\"true\");",
   "          }",
   "        case 41: break;",
   "        case 4: ",
   "          { return new Token(TokenType.INTEGRAL,yytext());",
   "          }",
   "        case 42: break;",
   "        case 12: ",
   "          { string.append('\\r');",
   "          }",
   "        case 43: break;",
   "        case 10: ",
   "          { yybegin(YYINITIAL); ",
   "                                   return new Token(TokenType.STRING,string.toString());",
   "          }",
   "        case 44: break;",
   "        case 15: ",
   "          { string.append('\\\"');",
   "          }",
   "        case 45: break;",
   "        case 20: ",
   "          { return new Token(TokenType.DECIMAL,yytext());",
   "          }",
   "        case 46: break;",
   "        case 13: ",
   "          { string.append('\\f');",
   "          }",
   "        case 47: break;",
   "        case 1: ",
   "          { throw new Error(\"Illegal character <\"+ yytext()+\">\");",
   "          }",
   "        case 48: break;",
   "        case 2: ",
   "          { ",
   "          }",
   "        case 49: break;",
   "        case 11: ",
   "          { string.append('\\t');",
   "          }",
   "        case 50: break;",
   "        default: ",
   "          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {",
   "            zzAtEOF = true;",
   "            return null;",
   "          } ",
   "          else {",
   "            zzScanError(ZZ_NO_MATCH);",
   "          }",
   "      }",
   "    }",
   "  }",
   "}"]
