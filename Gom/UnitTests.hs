------------------------------------------------------------------
-- |
-- Module      : Gom.UnitTests
-- Copyright   : (c) Paul Brauner 2009
--               (c) Emilie Balland 2009
--               (c) INRIA 2009
-- Licence     : GPL (see COPYING)
--
-- Maintainer  : paul.brauner@inria.fr
-- Stability   : provisional
-- Portability : non-portable (requires generalized newtype deriving)
--
-- Run all unit tests
--------------------------------------------------------------------

module Gom.UnitTests (testSuite) where

import Gom.Pretty ()
import Gom.Parser
import Gom.Checker
import Gom.Sig

-- imported test suites
import qualified Gom.SymbolTable

-- for t*.gom testing
import Test.Framework (Test,testGroup)
import Test.Framework.Providers.QuickCheck2 (testProperty)
import Test.Framework.Providers.HUnit (testCase)
import Test.HUnit.Base((@?=))
import System.FilePath((</>))

-- generated by cabal
import Paths_hgom (getDataFileName)

-- for generated parser tesing
import System.Cmd(rawSystem)
import Control.Monad(forM_)
import Data.Char(toLower)
import System.Directory
import Test.QuickCheck
import System.Exit

-- | models at which step of the chain a module failed
data FailsDuring = Parsing | Checking | Never deriving (Show,Eq)

-- | checks how far in the chain a module gets without 
-- raising a failure of some sort
failsDuring :: String -> FailsDuring
failsDuring s = 
  case parseModule s of
    Left  _ -> Parsing
    Right m -> case checkEverything m of
      Nothing -> Never
      Just _  -> Checking

-- | run failsDuring on some relative filePath
fileFailsDuring :: FilePath -> IO FailsDuring
fileFailsDuring f = do af <- getDataFileName f
                       failsDuring `fmap` readFile af

-- | regression suite
regressionSuite :: Test
regressionSuite = testGroup "regression tests" $

  map cook [("t1.gom",  Never   ), ("t2.gom",  Never   ),
            ("t3.gom",  Checking), ("t4.gom",  Parsing ),
            ("t5.gom",  Parsing ), ("t6.gom",  Parsing ),
            ("t7.gom",  Parsing ), ("t8.gom",  Parsing ),
            ("t9.gom",  Parsing ), ("t10.gom", Checking),
            ("t11.gom", Never   ), ("t12.gom", Never   )]

  where cook (s,f) = testCase (msg s f) (test s f)
        test s f = fileFailsDuring (prefix s) >>= (@?= f)
        prefix s = "test" </> "data" </> s
        msg s Never    = s ++ " is valid"
        msg s Parsing  = s ++ " fails parsing"
        msg s Checking = s ++ " fails checking"

-- | checks that @parse . pretty = id@
propParsePretty :: Module -> Bool
propParsePretty m = 
  case parseModule (show m) of
    Left  _  -> False
    Right m' -> m == m'

-- | @doInTempDir a@ creates a directory, change working directory 
-- to it, perform @a@ and comes back to original directory
doInTempDir :: IO a -> IO a
doInTempDir a = do
  tmp <- getTemporaryDirectory
  cur <- getCurrentDirectory
  setCurrentDirectory tmp
  r <- a
  setCurrentDirectory cur
  return r

-- | test that the generated parser is correct w.r.t. 
-- the generated pretty printer 
propGenParsePretty :: IO ()
propGenParsePretty = do
  sigs <- sample' $ arbitrary `suchThat` hasSort
  sigs `forM_` \sig -> doInTempDir $
    case sig of
      Module m _ (SortDef s _:_) -> do
        writeFile "Test.gom" $ show sig
        _ <- rawSystem "hgom" ["-r","Test.gom"]
        writeFile "Test.java" $ template m (show s)
        st <- rawSystem "javac" ["Test.java"]
        st @?= ExitSuccess
      _ -> error "never happens"

  where hasSort = not . null . sortDefs
        template m s = unlines
          ["import " ++ map toLower m ++ ".types.*;",
           "public class Test {",
           "  public static void main(String[] args) {",
           "    for(int i=0; i<10; i++) {",
           "      " ++ s ++ " t = " ++ s ++ ".makeRandom(i);",
           "      if (!" ++ s ++ ".fromString(t.toString()).equals(t))",
           "        System.exit(1);",
           "    }",
           "  }",
           "}"]

-- | cross modules quickcheck tests
crossModuleSuite :: Test
crossModuleSuite = testGroup "cross module properties:" 
  [testProperty "parse . pretty = id" propParsePretty,
   testCase "generated parse/pretty (10 sigs x 10 terms)" propGenParsePretty]

-- | all tests
testSuite :: [Test]
testSuite = [regressionSuite,
             crossModuleSuite,
             Gom.SymbolTable.testSuite]
