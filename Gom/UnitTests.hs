------------------------------------------------------------------
-- |
-- Module      : Gom.UnitTests
-- Copyright   : (c) Paul Brauner 2009
--               (c) Emilie Balland 2009
--               (c) INRIA 2009
-- Licence     : GPL (see COPYING)
--
-- Maintainer  : paul.brauner@inria.fr
-- Stability   : provisional
-- Portability : non-portable (requires generalized newtype deriving)
--
-- Run all unit tests
--------------------------------------------------------------------

module Gom.UnitTests (testSuite) where

import Test.Framework (Test,testGroup)
import Test.Framework.Providers.QuickCheck2 (testProperty)
import Test.Framework.Providers.HUnit (testCase)
import Test.HUnit.Base((@?=))
import System.FilePath((</>))

-- generated by cabal
import Paths_hgom (getDataFileName)

import qualified Gom.SymbolTable
import Gom.Pretty ()
import Gom.Parser
import Gom.Checker
import Gom.Sig

-- | models at which step of the chain a module failed
data FailsDuring = Parsing | Checking | Never deriving (Show,Eq)

-- | checks how far in the chain a module gets without 
-- raising a failure of some sort
failsDuring :: String -> FailsDuring
failsDuring s = 
  case parseModule s of
    Left  _ -> Parsing
    Right m -> case checkEverything m of
      Nothing -> Never
      Just _  -> Checking

-- | run failsDuring on some relative filePath
fileFailsDuring :: FilePath -> IO FailsDuring
fileFailsDuring f = do af <- getDataFileName f
                       failsDuring `fmap` readFile af

-- | regression suite
regressionSuite :: Test
regressionSuite = testGroup "regression tests" $

  map cook [("t1.gom", Never   ), ("t2.gom", Never   ),
            ("t3.gom", Checking), ("t4.gom", Parsing ),
            ("t5.gom", Parsing ), ("t6.gom", Parsing ),
            ("t7.gom", Parsing ), ("t8.gom", Parsing ),
            ("t9.gom", Parsing ), ("t10.gom", Checking),
            ("t11.gom", Never   ), ("t12.gom", Never   )]

  where cook (s,f) = testCase (msg s f) (test s f)
        test s f = fileFailsDuring (prefix s) >>= (@?= f)
        prefix s = "test" </> "data" </> s
        msg s Never    = s ++ " is valid"
        msg s Parsing  = s ++ " fails parsing"
        msg s Checking = s ++ " fails checking"

-- | checks that @parse . pretty = id@
propParsePretty :: Module -> Bool
propParsePretty m = 
  case parseModule (show m) of
    Left  _  -> False
    Right m' -> m == m'

-- | cross modules quickcheck tests
crossModuleSuite :: Test
crossModuleSuite = testGroup "cross module properties:" 
  [testProperty "parse . pretty = id" propParsePretty]

-- | all tests
testSuite :: [Test]
testSuite = [regressionSuite,
             crossModuleSuite,
             Gom.SymbolTable.testSuite]

